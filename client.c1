#include "client.h"
#include <sys/time.h>
#include <stdio.h>
#include "csapp.h"
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define port 2121
#define MAX_NAME_LEN 256
#define MAXSEND 256

rio_t rio;
struct Request* req;
int main(int argc, char **argv)
{
    int clientfd, fd, port2;
    char *buf, *host, *hidefile;
    struct timeval start, end;
    size_t len=0, n=0;

    if (argc != 2) {
        fprintf(stderr, "usage: %s <host>\n", argv[0]);
        exit(0);
    }
    host = argv[1];//On recupere le hostname du serveur (127.0.0.1 pour les tests)

    clientfd = Open_clientfd(host, port);//On demande la connexion au serveur maitre
    printf("client connected to server %s\n", host);

    Rio_readn(clientfd, &port2, sizeof(int)); //On recupert le port du serveur esclave

    printf("Vous aller être redirigé vers l'esclave %d\n", port2);

    clientfd = Open_clientfd(host, port2);//On demande la connexion au serveur esclave

    req = malloc(sizeof(struct Request));//On alloue de la memoire pour la Request
    req->clientfd = clientfd;//On recupere le descripteur du socket

    Rio_readinitb(&rio, clientfd);//On initialise Rio

    while (1) {
      printf("Tapez votre requete : \n");
      buf = (char*)malloc(sizeof(char)*MAXLINE);
      Fgets(buf, MAXLINE, stdin);
      req->filename = (char*)malloc(sizeof(char)*MAXLINE);
      req->cmd = (char*)malloc(sizeof(char)*MAXLINE);
      req->content = (char*)malloc(sizeof(char)*MAXLINE);
      sscanf(buf, "%s %s %s", req->cmd, req->filename, req->content);//On recupere la requette tapée par le client

      /*
      Pour savoir si on a déjà tenté de télécharger un fichier, on créer un fichier temporaire au début du téléchargeme,t
      Lorsque le téléchargement est terminé on le supprime
      Si il existe un fichier temporaire associé au fichier que lon veut télécharger
        cela signifie qu'on a déjà essayer de le télécharger, on télécharge uniquement les données manquante
      */
      if(!strcmp(req->cmd, "get")){
          gettimeofday(&start, NULL);
          Rio_writen(req->clientfd, buf, strlen(buf));//On envoie la requete au serveur
          hidefile = (char*)malloc(sizeof(char)*MAX_NAME_LEN);
          hidefile[0]='.';
          strcat(hidefile, req->filename);//On créer le nom du fichier temporaire
          if(stat(hidefile,&req->sbuf) != 0){//Si le fichier temporaire n'existe pas
              open(hidefile, O_RDWR | O_CREAT, 0666);//On le créer
              fd = open(strcat(req->filename, "1"), O_RDWR | O_CREAT, 0666);//On creer un fichier pour le téléchargement
              free (buf);
              buf = (char*)malloc(sizeof(char)*MAXSEND);
              while((n=Rio_readn(req->clientfd, buf, MAXSEND)) > 0) {//Tant qu'on recoit des données, on les ecrit dans le fichier
                  rio_writen(fd, buf, n);
                  len+=n;
                  free(buf);
                  buf = (char*) malloc(sizeof(char)*MAXSEND);
                  if(n==0){
                    printf("Téléchargement fini\n");
                    break;
                  }
              }
              Close(fd);
              gettimeofday(&end, NULL);
              double temps = ((end.tv_sec+(double)end.tv_usec/1000000)-(start.tv_sec+(double)start.tv_usec/1000000));
              printf("%lu bytes received in %f sec (%f bytes / sec) \n",len, temps, ((double)(len/temps)));//On affiche le statistiques
              if(len == 0){
                  printf("Le téléchargement a echoée\n");
                  remove(req->filename);
              }
              remove(hidefile);
          }else{//Si le fichier temporaire existe
            fd = open(strcat(req->filename, "1"), O_WRONLY);
            stat(req->filename,&req->sbuf);
            int dejaLu = req->sbuf.st_size;//On recupere la taille des données déjà téléchargé
            free (buf);
            buf = (char*)malloc(sizeof(char)*MAXSEND);
            while((n=Rio_readn(req->clientfd, buf, MAXSEND)) > 0) {
                if(n==0){
                  printf("Téléchargement fini\n");
                  break;
                }
                int tmp = dejaLu;
                dejaLu-=n;
                printf("%d\n", dejaLu);
                if(dejaLu <= 0){//On ecrit si ce sont des données non téléchargées
                  rio_writen(fd, buf, n);
                  free(buf);
                  buf = (char*) malloc(sizeof(char)*MAXSEND);
                  len+=n;
                }else{//Sinon on déplace le curseur
                  if(n<tmp)
                      lseek(fd, n, SEEK_CUR);
                  else
                      lseek(fd, n-tmp, SEEK_CUR);
                }

            }
            gettimeofday(&end, NULL);
            double temps = ((end.tv_sec+(double)end.tv_usec/1000000)-(start.tv_sec+(double)start.tv_usec/1000000));
            printf("%lu bytes received in %f sec (%f bytes / sec) \n",len, temps, ((double)(len/temps)));
            remove(hidefile);
          }
      }else if(!strcmp(req->cmd, "bye")){//On ferme la connexion
          Rio_writen(req->clientfd, req->cmd, strlen(req->cmd));
          printf("fin de la connexion\n");
          exit(0);
      }else{//On stoppe la connection
          printf("Commande %s inconnue\n", req->cmd);
          printf("fin de la connexion\n");
      